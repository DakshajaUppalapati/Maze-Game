#! /usr/bin/python
from Tkinter import *
import tkSimpleDialog
import tkMessageBox
from random import shuffle, randrange
import copy
import time
import sys
import os

tkMessageBox.showinfo( "Greetings!","Hey maze runner!!!You are a Here")

tkMessageBox.showinfo( "Rules","1. Canvas_width and Canvas_height must be divided by cell_length\n\t cell_length is nothing but size of  maze\n2.canvas_width/cell_length <= 20(excluding Floating point numbers")

'''print "Rules to enter canvas_width and height:"
print "1. Canvas_width and Canvas_height must be divided by cell_length "
print "\t cell_length is nothing but size of  maze"
print "2.canvas_width/cell_length <= 20(excluding Floating point numbers similarly for canvas_height\n\n\n"'''


canvas_width = tkSimpleDialog.askinteger("Canvas_width","What is the width of the canvas") # canvas width
canvas_height = tkSimpleDialog.askinteger("Canvas_height","What is the height of the canvas") #canvas height
cell_length = tkSimpleDialog.askinteger("Cell_length","What is the length of a cell") # cell length

if (canvas_width%cell_length != 0) or (canvas_height%cell_length != 0):
	tkMessageBox.showinfo( "Error","Sorry u have given wrong inputs\ncanvas_width and canvas_height must be divided by cell_length")
	'''print "Sorry u have given wrong inputs"
	print "canvas_width and canvas_height must be divided by cell_length"'''
	sys.exit()

master = Tk()	#First Canvas
master.title("Maze_Application")	#Title of GUI_Canvas
w_width = 100   	
w_height = 100    #width and height of canvas text message box asking to play
mid = cell_length/2
PathFound = False
s_0=0	
s_1=0
g_0=0
g_1=0
e = 0
f = 0
delete_stack = []
direction_line=0
w = Canvas(master,width=w_width,height=w_height)

global canvas

Path = []
MyStack = []				# Stack to store the visited cells
length = canvas_width/cell_length	# No. of cells along with x-axis in grid
breadth = canvas_height/cell_length	# No. of cells along with y-axis in grid
matrix = [[0 for x in range((canvas_width/cell_length)+1)] for y in range((canvas_height/cell_length)+1)]# empty 2D list

delete_line = [[0 for x in range((canvas_width/cell_length)+1)] for y in range((canvas_height/cell_length)+1)]
maze = [[0 for i in range((canvas_width/cell_length)+1)] for j in range((canvas_height/cell_length)+1)]

#generating a grid and storing its unique ids in a list and also put all the cells not visited
def grid(canvas, cell_length):
	for i in range(0,canvas_height,cell_length):
		for j in range(0,canvas_width,cell_length):
		
		# Storing unique id's generated by create_line() in p,q
			p=canvas.create_line(j+cell_length,i,j+cell_length,i+cell_length,fill = "blue")#vertical line
			q=canvas.create_line(j,i+cell_length,j+cell_length,i+cell_length,fill = "red") #horizontal line
			matrix[i/cell_length][j/cell_length] = p,q,False # Storing each pair of vertical and horizontal line in matrix 2D list
	'''print matrix[i/cell_length] # Printing row-wise
	print "\n"
	return None'''
   
    
# Creating a maze 
def walk(x, y,canvas):
	# if current cell (x,y) not in stack then append (x,y) into stack.
	if (x,y) not in MyStack:
		MyStack.append((x,y)) # checking whether a cell is visited or not
		
	print "current cell = ",x,y
	matrix[x][y]=matrix[x][y][:2] + (True,) # marking the cell as visited
	#print matrix[x][y]
	d = [(x - 1, y), (x, y + 1),(x + 1, y),(x, y - 1)] # considering 4 neighbours of (x,y)
	#print d
	h=copy.copy(d) # created a list 'h' having the data of 'd'
	
	# s=[0,10) and t = [0,20)
	# Eleminating cells in 'd' if 's' and 't' are not in given range
	# And also we have to consider only unvisited cells. so we have to remove visited cells.
	for (s,t) in d:
	      #print s,t,matrix[s][t]
	      if (s,t) in h:
	      	if s<0 or t<0 or s >= breadth or t >= length or matrix[s][t][2] == True:
	      		h.pop(h.index((s,t)))
	       		'''print "after deleting elements from h"
	       		print h'''
	print "unvisited cells of current cell are",h
	#now we got all unvisited cells into h 
	# if len(h) is zero i.e. there are no unvisited neighbours of (x,y) then it should backtrack the stack
	if len(h) == 0:
	       	MyStack.pop()	# deletes the top element i.e. last added item in Stack(MyStack)
	        #print "length of MyStack",len(MyStack)
	       	if len(MyStack)==0:	# if the are no elements in stack to backtrack then it is the end.
	       		return
	       	#print "Now the current cell is",MyStack[len(MyStack)-1][0],MyStack[len(MyStack)-1][1]
	       	walk(MyStack[len(MyStack)-1][0],MyStack[len(MyStack)-1][1],canvas)	# top element in stack
	       			
	if len(MyStack)==0:
	       	return      		
	       	
			
	randitem_index=randrange(len(h)) # among neighbours in 'h', It choose a cell randomly.
       	rand_item = h[randitem_index]
       	xx = rand_item[0]
       	yy = rand_item[1]	# generating random initial cell in grid
       	
       	# this is done to remove wall between current cell and choosen cell.
       	''' 	 _ _ _
       		|_|_|_|   x is constant
       		   _
       		  |_|
		  |_|	  y is constant
  		  |_|    '''
       	
       	# deleting the wall between choosen cell and current cell
       	if xx == x and yy > y:
		canvas.delete(matrix[xx][yy-1][0])
		matrix[xx][yy-1]=(-1,) + matrix[xx][yy-1][1:]
		matrix[xx][yy-1]=matrix[xx][yy-1][:2] + (True,)
		pp,qq = xx,yy
	elif xx == x and yy < y:
		canvas.delete(matrix[xx][yy][0])
		matrix[xx][yy]=(-1,) + matrix[xx][yy][1:]
		matrix[xx][yy]=matrix[xx][yy][:2] + (True,)
		pp,qq = xx,yy
	elif yy == y and xx > x:
		canvas.delete(matrix[xx-1][yy][1])
		matrix[xx-1][yy]= matrix[xx-1][yy][:1]+(-1,) + matrix[xx-1][yy][2:]
		matrix[xx-1][yy] = matrix[xx-1][yy][:2] + (True,)
		pp,qq = xx,yy
	else:	#yy == y and xx < x
		canvas.delete(matrix[xx][yy][1])
		matrix[xx][yy]= matrix[xx][yy][:1]+(-1,)+ matrix[xx][yy][2:]
		matrix[xx][yy] = matrix[xx][yy][:2] + (True,) 
		pp,qq = xx,yy
	walk(pp,qq,canvas) #after deleting wall we are taking the choosen cell as current cell
	#this process is done until all cells are visited
	return None


def make_maze():
	# Selecting a random cell (u,v) from the created grid
	global canvas
	master1=Tk()
	master1.title("Maze_generation")
	canvas = Canvas(master1,width=canvas_width,height=canvas_height)
	#print "in make_maze"
	grid(canvas,cell_length)
	#print "after grid"
	u=randrange(breadth)
	v=randrange(length)
	walk(u,v,canvas)
	#print "Maze is generated"
	#this is to generate starting and ending points in maze
	start = (randrange(breadth),randrange(length))
	goal = (randrange(breadth),randrange(length))
	#winsound.PlaySound('lie_detector.wav', winsound.SND_ALIAS | winsound.SND_ASYNC)
	print "Starting point is",start
	print "Ending point is",goal
	global s_0,s_1,g_0,g_1,e,f
	s_0 = start[0]
	s_1=start[1]
	g_0=goal[0]
	g_1=goal[1]
	#this stack is used to delete line when user want to back trace the visited cells
	delete_stack.append((s_0,s_1)) 
	
	#to mark starting and ending points of the user in maze
	e = canvas.create_oval(s_1*cell_length, s_0*cell_length, (s_1+1)*cell_length, (s_0+1)*cell_length, width=1, fill='blue')
	b = canvas.create_oval(s_1*cell_length, s_0*cell_length, (s_1+1)*cell_length, (s_0+1)*cell_length, width=1, fill='green')
	f = canvas.create_oval(g_1*cell_length, g_0*cell_length, (g_1+1)*cell_length, (g_0+1)*cell_length, width=1, fill='red')
	

	def up_arrow():
		global s_0,s_1,g_0,g_1
		global e,f
		canvas.delete(e)
		#print delete_stack
		
		if matrix[s_0-1][s_1][1] != -1: 
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		
		if (s_0-1,s_1) in delete_stack:
			if (s_0 > 0 and s_1 > 0) :
				while (matrix[s_0-1][s_1][1] == -1 and (matrix[s_0-1][s_1][0] != -1 and matrix[s_0-1][s_1-1][0] != -1)):
					#print "in delete while"
					canvas.delete(delete_line[s_0-1][s_1])
					s_0 = s_0 - 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0-1][s_1][1] == -1:
					print "in delete if"
					canvas.delete(delete_line[s_0-1][s_1])
					s_0 = s_0 - 1
					delete_stack.pop()
					#print delete_stack
			elif s_1 == 0 :
				while (matrix[s_0-1][s_1][1] == -1 and matrix[s_0-1][s_1][0] !=-1) :
					canvas.delete(delete_line[s_0-1][s_1])
					s_0 = s_0 - 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0-1][s_1][1] == -1:
					#print "in delete if"
					canvas.delete(delete_line[s_0-1][s_1])
					s_0 = s_0 - 1
					delete_stack.pop()
					#print delete_stack

			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')

		
		elif (s_0 == 0 and s_1 == 0):
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		elif s_0 == 0 :
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		elif matrix[s_0-1][s_1][1] != -1:
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		
		elif (s_0 > 0 and s_1 > 0) :
			while (matrix[s_0-1][s_1][1] == -1 and (matrix[s_0-1][s_1][0] != -1 and matrix[s_0-1][s_1-1][0] != -1)) :	
				#print "while"
				#print matrix[s_0-1][s_1]
				#print matrix[s_0-1][s_1-1]
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0-1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 -1
				delete_stack.append((s_0,s_1))
				#print s_0
	
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
				
				
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			
			if matrix[s_0-1][s_1][1] == -1:
			
				
				#print "after while"
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0-1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 -1
				delete_stack.append((s_0,s_1))
				#print s_0
				
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			
			
		elif s_1 == 0 :
			while (matrix[s_0-1][s_1][1] == -1 and matrix[s_0-1][s_1][0] !=-1) :
				#print "while"
				#print matrix[s_0-1][s_1]
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0-1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 - 1
				delete_stack.append((s_0,s_1))
				#print s_0
				
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
				
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			if matrix[s_0-1][s_1][1] == -1 :
				
				#print "after while"
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0-1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 -1
				delete_stack.append((s_0,s_1))
				
				#print s_0
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
		print "The current position of the user is",s_0,s_1
	
	def down_arrow():
		global s_0,s_1,g_0,g_1,e,f
		canvas.delete(e)
		
		if matrix[s_0][s_1][1] != -1:
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
			
		if (s_0+1,s_1) in delete_stack:
			if s_0 == 0 and s_1 == 0:
					while (matrix[s_0][s_1][1] == -1) and (matrix[s_0+1][s_1][0] != -1):
						#print "in delete while"
						canvas.delete(delete_line[s_0+1][s_1])
						s_0 = s_0 + 1
						delete_stack.pop()
						#print delete_stack
						if delete_stack == [(s_0,s_1)]:
							return None
					if matrix[s_0][s_1][1] == -1:
						#print "in delete if"
						canvas.delete(delete_line[s_0+1][s_1])
						s_0 = s_0 + 1
						delete_stack.pop()
						#print delete_stack
			elif (s_0 > 0 and s_1 > 0) or (s_0 == 0) :
				while (matrix[s_0][s_1][1] == -1 and (matrix[s_0+1][s_1][0] != -1 and matrix[s_0+1][s_1-1][0] != -1)):
					#print "in delete while"
					canvas.delete(delete_line[s_0+1][s_1])
					s_0 = s_0 + 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0][s_1][1] == -1:
					#print "in delete if"
					canvas.delete(delete_line[s_0+1][s_1])
					s_0 = s_0 + 1
					delete_stack.pop()
					#print delete_stack
			
			elif s_1 == 0:
					while (matrix[s_0][s_1][1] == -1 and matrix[s_0+1][s_1][0] != -1 ) :
						#print "in delete while"
						canvas.delete(delete_line[s_0+1][s_1])
						s_0 = s_0 + 1
						delete_stack.pop()
						#print delete_stack
					if matrix[s_0][s_1][1] == -1:
						#print "in delete if"
						canvas.delete(delete_line[s_0+1][s_1])
						s_0 = s_0 + 1
						delete_stack.pop()
						#print delete_stack
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')

			'''elif matrix[s_0][s_1][1] != -1:
				tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
				return None'''
	
		elif s_0 == 0 and s_1 == 0:
			while (matrix[s_0][s_1][1] == -1) and (matrix[s_0+1][s_1][0] != -1):
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0+1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 +1
				delete_stack.append((s_0,s_1))
				#print s_0
				
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			#print "after while"
			
			if matrix[s_0][s_1][1] == -1:
				
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0+1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 +1
				delete_stack.append((s_0,s_1))
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
				#print s_0
			
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
		elif (s_0 > 0 and s_1 > 0) or (s_0 == 0) :
			while (matrix[s_0][s_1][1] == -1 and (matrix[s_0+1][s_1][0] != -1 and matrix[s_0+1][s_1-1][0] != -1)):
				'''print "while"
				print matrix[s_0][s_1]
				print matrix[s_0+1][s_1]
				print matrix[s_0+1][s_1-1]'''
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0+1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 +1
				delete_stack.append((s_0,s_1))
				#print s_0
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			#print "after while"
			
			if matrix[s_0][s_1][1] == -1:
				
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0+1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 +1
				delete_stack.append((s_0,s_1))
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
				#print s_0
			
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
						
		elif s_1 == 0 :
			while (matrix[s_0][s_1][1] == -1 and matrix[s_0+1][s_1][0] != -1 ) :
				#print "while"
				#print matrix[s_0][s_1]
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0+1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 +1
				delete_stack.append((s_0,s_1))
				#print s_0
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None	
				
			if matrix[s_0][s_1][1] == -1:
				#print "after while"
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,(s_1*cell_length)+mid,((s_0+1)*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_0 = s_0 +1
				delete_stack.append((s_0,s_1))
				#print s_0	
				
			if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					return None
			
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
		print "The current position of the user is",s_0,s_1			
	def left_arrow():
		
		global s_0,s_1,g_0,g_1,e,f
		canvas.delete(e)
		
		if matrix[s_0][s_1-1][0] != -1:
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		if (s_0,s_1-1) in delete_stack:
			if (s_0 > 0 and s_1 > 0) :
				while (matrix[s_0][s_1-1][0] == -1 and (matrix[s_0-1][s_1-1][1] != -1 and matrix[s_0][s_1-1][1] != -1)) :
					#print "in delete while"
					canvas.delete(delete_line[s_0][s_1-1])
					s_1 = s_1 - 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0][s_1-1][0] == -1:
					#print "in delete if"
					canvas.delete(delete_line[s_0][s_1-1])
					s_1 = s_1 - 1
					delete_stack.pop()
					#print delete_stack
			
			elif  s_0 == 0:
				while (matrix[s_0][s_1-1][0] == -1 and matrix[s_0][s_1-1][1] != -1) :
					#print "in delete while"
					canvas.delete(delete_line[s_0][s_1-1])
					s_1 = s_1 - 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0][s_1-1][0] == -1:
					#print "in delete if"
					canvas.delete(delete_line[s_0][s_1-1])
					s_1 = s_1 - 1
					delete_stack.pop()
					#print delete_stack
				
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
		
		elif (s_0 == 0 and s_1 == 0):
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		elif s_1 == 0:
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		elif matrix[s_0][s_1-1][0] != -1:
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
		
		elif (s_0 > 0 and s_1 > 0) :
			while (matrix[s_0][s_1-1][0] == -1 and (matrix[s_0-1][s_1-1][1] != -1 and matrix[s_0][s_1-1][1] != -1)) :
				#print "while"
				#print matrix[s_0][s_1-1]
				#print matrix[s_0-1][s_1-1]
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1-1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 -1
				delete_stack.append((s_0,s_1))
				#print s_1
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None	
			#print "after while"
			
			if matrix[s_0][s_1-1][0] == -1:
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1-1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 -1
				delete_stack.append((s_0,s_1))
				#print s_1
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			
		elif  s_0 == 0:
			
			while (matrix[s_0][s_1-1][0] == -1 and matrix[s_0][s_1-1][1] != -1) :
				#print "while"
				#print matrix[s_0][s_1-1]
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1-1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 -1
				delete_stack.append((s_0,s_1))
				#print s_1
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
					
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			
			if matrix[s_0][s_1-1][0] == -1:
				#print "after while"
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1-1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 5)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 -1
				delete_stack.append((s_0,s_1))
				#print s_1
	
			if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None

			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
		print "The current position of the user is",s_0,s_1
			
	def right_arrow():
		global s_0,s_1,g_0,g_1,e,f
		canvas.delete(e)
		if matrix[s_0][s_1][0] != -1:
			tkMessageBox.showinfo( "oops!","This is not correct path. Choose Alternate path")
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			return None
			
		if (s_0,s_1+1) in delete_stack:
			if s_0 == 0 and s_1 == 0:
				while (matrix[s_0][s_1][0] == -1 and matrix[s_0][s_1+1][1] != -1):
					#print "in delete while"
					canvas.delete(delete_line[s_0][s_1+1])
					s_1 = s_1 + 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0][s_1][0] == -1:
					#print "in delete if"
					canvas.delete(delete_line[s_0][s_1+1])
					s_1 = s_1 + 1
					delete_stack.pop()
					#print delete_stack
			elif (s_0 > 0 and s_1 > 0) or (s_1 == 0):
				while (matrix[s_0][s_1][0] == -1 and (matrix[s_0-1][s_1+1][1] != -1 and matrix[s_0][s_1+1][1] != -1)) :
					#print "in delete while"
					canvas.delete(delete_line[s_0][s_1+1])
					s_1 = s_1 + 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0][s_1][0] == -1:
					#print "in delete if"
					canvas.delete(delete_line[s_0][s_1+1])
					s_1 = s_1 + 1
					delete_stack.pop()
					#print delete_stack
			
			elif s_0 == 0:
				while matrix[s_0][s_1][0] == -1 and matrix[s_0][s_1+1][1] != -1:
					#print "in delete while"
					canvas.delete(delete_line[s_0][s_1+1])
					s_1 = s_1 + 1
					delete_stack.pop()
					#print delete_stack
					if delete_stack == [(s_0,s_1)]:
						return None
				if matrix[s_0][s_1][0] == -1:
					#print "in delete if"
					canvas.delete(delete_line[s_0][s_1+1])
					s_1 = s_1 + 1
					delete_stack.pop()
					#print delete_stack	
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')

		elif s_0 == 0 and s_1 == 0:
			while (matrix[s_0][s_1][0] == -1 and matrix[s_0][s_1+1][1] != -1):
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1+1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 2)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 + 1
				delete_stack.append((s_0,s_1))
				#print s_1
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			
			#print "after while"
			
			if matrix[s_0][s_1][0] == -1:
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1+1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 2)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 + 1
				delete_stack.append((s_0,s_1))
				#print s_1
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			
		elif (s_0 > 0 and s_1 > 0) or (s_1 == 0):
			while (matrix[s_0][s_1][0] == -1 and (matrix[s_0-1][s_1+1][1] != -1 and matrix[s_0][s_1+1][1] != -1)) :
				'''print "while"
				print matrix[s_0][s_1]
				print matrix[s_0-1][s_1+1]
				print matrix[s_0][s_1+1]'''
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1+1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 2)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 + 1
				delete_stack.append((s_0,s_1))
				#print s_1
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			
			#print "after while"
			
			if matrix[s_0][s_1][0] == -1:
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1+1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 2)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 + 1
				delete_stack.append((s_0,s_1))
				#print s_1
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
			
		
		elif s_0 == 0 :
			while matrix[s_0][s_1][0] == -1 and matrix[s_0][s_1+1][1] != -1:
				#print "while"
				#print matrix[s_0][s_1]

				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1+1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 2)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 +1
				delete_stack.append((s_0,s_1))
				#print s_1
				if s_0 == g_0 and s_1 == g_1:
					tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
					print "The current position of the user is",s_0,s_1
					return None
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				print "The current position of the user is",s_0,s_1
				return None
			
			if matrix[s_0][s_1][0] == -1:
				#print "after while"
				path_line = canvas.create_line((s_1*cell_length)+mid,(s_0*cell_length)+mid,((s_1+1)*cell_length)+mid,(s_0*cell_length)+mid,fill = "green",width = 2)
				delete_line[s_0][s_1] = path_line
				s_1 = s_1 + 1
				delete_stack.append((s_0,s_1))
				#print s_1
			if s_0 == g_0 and s_1 == g_1:
				tkMessageBox.showinfo( "Congrajulations!","Yes. Good Job")
				return None
			e = canvas.create_oval((s_1*cell_length) + (mid - 20), (s_0*cell_length)+(mid-20), ((s_1)*cell_length)+(mid + 20), ((s_0)*cell_length) + (mid + 20 ), width=1, fill='blue')
		print "The current position of the user is",s_0,s_1
			
	def create_events(canvas):
		print "Now user can use arrows to play the game"
		def move_cell(event):
			global s_0,s_1,g_0,g_1
			if event.keysym == 'Up':
				up_arrow()
			if event.keysym == 'Down':
				down_arrow()
			if event.keysym == 'Left':
				left_arrow()
			if event.keysym == 'Right':
				right_arrow()
	
		canvas.bind_all('<KeyPress-Up>', move_cell)
		canvas.bind_all('<KeyPress-Down>', move_cell)
		canvas.bind_all('<KeyPress-Left>', move_cell)
		canvas.bind_all('<KeyPress-Right>',move_cell)
	
	create_events(canvas)
	canvas.pack() 
	print "after walk"				
	return None


frame = Frame(master)


button = Button(frame, text="Play", fg="red", bd = 3,command = make_maze)
button.pack( side=LEFT, padx=20,pady=10)

def instruction1():
   tkMessageBox.showinfo( "Instructions","Press 'Up' key to move UP\nPress 'Down' key to move Down\nPress 'Left' key to move Left\nPress 'Right' key to move Right" )
   return None
button = Button(frame, text="Instructions", fg="green", bd = 3,command = instruction1)

button.pack( side=LEFT, padx=20,pady=10)

frame.pack()
 
w.pack()

mainloop()

